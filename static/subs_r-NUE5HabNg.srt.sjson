{"start":[0,692,3575,5210,8710,12610,13850,18820,21410,22620,25910,26990,29980,32600,35070,38400,42230,44913,45360,47140,51740,53290,54940,57850,60930,64069,65740,69022,72060,74610,76580,79050,82420,86650,88980,89210,92150,96860,98680,100860,101650,103220,105650,109490,111740,114430,116650,119050,122100,122990,125430,126680,129720,131760,133450,135460,136610,140410,141850,144150,146070,147960,149980,152470,153890,157530,159360,161930,163270,165050,167890,172080,176980,179670,183720,187610,189160,191800,193190,194770,197600,199180,202110,206050,208400,211510,212160,215290,218441,221520,224060,226930,230360,232760,235560,238830,241320,244850,246860,252980,257200,259980,261060,262140,265490,268260,269490,272410,276720,279260,280840,283540,285480,288780,290300,291550],"end":[692,3575,5210,8710,12610,13850,18820,21410,22620,25910,26990,29980,32600,35070,38400,42230,44913,45360,47140,51740,53290,54940,57850,60930,64069,65740,69022,72060,74610,76580,79050,82420,86650,88980,89210,92150,96860,98680,100860,101650,103220,105650,109490,111740,114430,116650,119050,122100,122990,125430,126680,129720,131760,133450,135460,136610,140410,141850,144150,146070,147960,149980,152470,153890,157530,159360,161930,163270,165050,167890,172080,176980,179670,183720,187610,189160,191800,193190,194770,197600,199180,202110,206050,208400,211510,212160,215290,218441,221520,224060,226930,230360,232760,235560,238830,241320,244850,246860,252980,257200,259980,261060,262140,265490,268260,269490,272410,276720,279260,280840,283540,285480,288780,290300,291550,292867],"text":["","PROFESSOR: Now what we'd like to do is we'd like to go back to our tree","search algorithm.","If you think about the tree search algorithm we presented, it turns out","you do a lot of repeated work, because the search tree essentially unrolls","the search graph.","And we'd like to save time by avoiding retracing our steps, because the","second time you do the work is not going to be any more useful than the","first time you did it.","So as a good, important general idea in computer science, avoid repeating","work you've already done.","Now we're going to apply that in the context of search with an idea called","graph search.","So what's up with this?","Well, let's say you have this state graph on the left.","So the nodes are ABC and D. And from A there's two ways to get to B. And","there's two ways to get from B to C. And there's two ways to get from C to","D.","And so this graph is not that big.","But if you think about it, it includes quite a lot of plans.","So the search tree, what's it look like?","It's got A at the root.","But then it's kind of got B twice, because there's two ways to get there.","And then under each of those B's it's got C twice.","And it's going to be this exponential unrolling of this graph.","And in general, this is what happens, right?","You're going to get exponentially more work, because when you do a search in","this tree, well, you're going to kind of search from B at some point.","And then when that's all done, say you're doing depth research, you're","then going to search over here from B again.","And it's not like the second B is going to be particularly more","informative than the first B. Now it may be that one or the other is the","right one to do, and so we might have to worry about which one we should do.","But we probably don't want to do both.","OK?","Because what's underneath those trees is the same.","So let's see if we can figure out a way to avoid repeating work.","Let's say we're doing breadth-first search.","Well, if we do breadth-first search, we all know what happens.","We do s.","Then we do d, e, and p.","And then we do the next layer and the next layer and the next layer.","That means that we're going to do this node e early.","And at some point later we're going to do this node.","Now, breadth-first search is going to be looking for the shallowest goal,","which I guess is here.","It's under this subtree through e.","But what about this subtree here versus this subtree?","They're the same.","The lower one is not going to tell you anything the higher","one didn't tell you.","And so if you're already in the process of exploring the higher one--","let's say the higher e is on your fringe--","there's no reason to explore both.","So you need to be careful about which one you explore, but you","don't want to do both.","In the case of breadth-first search, here are some nodes that we already","would have expanded.","And so we probably shouldn't expand them again, because we're not going to","discover anything new.","How do we do this in our algorithm?","Changing the algorithm is incredibly easy.","Understanding its consequences is hard.","The change in the algorithm is simple.","You don't want to expand a state twice, don't do it.","All right, so how are we going to do that?","Well, we're going to run our tree search, just like we always have.","There's a fringe.","There's a strategy for removing things on the fringe.","Successors, goal tasks, none of that has changed.","Only one small change, and that is that every time we expand a state,","meaning we call Get Successors on it, every time we expand a state, then we","keep track of the set we've expanded.","So that set of states we've expanded is called the closed set.","Word of warning, lots of books and treatments call it a closed list.","It is a closed set.","You do not want to implement this thing as a list.","Back to the flow.","How do we implement this algorithm?","Well, we're going to do a tree search, and we're going to keep track of the","set of states we've already expanded.","We go node by node, expanding just like before.","But before we expand a node, we check to make sure it's a state that we've","never expanded before.","If it is a state we've expanded before, we've already got it covered.","We skip it.","We do not enqueue its children onto the fringe.","Because if it's a new state, then we do expand it.","It's very important to store the closed set as a set, not as a list, no","matter how many people slip up and say closed list.","The access to this is checking membership.","Checking membership in a set is more efficient than in a list.","And if you implement this is a list, you will be sad.","","All right, so we made a change to our search algorithm.","Sometimes we don't expand a node.","So sometimes, rather than enqueuing the children, we just don't.","Can this wreck the completeness of our search.","That is, by refusing to expand certain nodes in the tree, can we lose the","ability to guarantee that we find a solution?","Could it be that there was one goal and we just lost it?","Bye, bye goal.","Can that happen?","That actually can't happen, because the only time we don't expand","something is when there's an equivalent state in some other node","that we did expand.","So there will still be a path to this goal.","So completeness is absolutely unaffected by graph search.","How about optimality?","Optimality's a little trickier, OK?","Because there were these two subtree under e.","And we know we've got one of them.","And so we know if there's a path in one, there's a path in the other.","But maybe we got the wrong one.","Maybe we kept the wrong subtree.",""]}